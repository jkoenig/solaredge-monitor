---
phase: 10-forecast-fix
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - forecast_api.py
  - screens/forecast.py
autonomous: true

must_haves:
  truths:
    - "Forecast.Solar API response parses without KeyError — reads data['result'] directly as flat date->Wh mapping"
    - "Forecast screen uses identical layout grid as production/consumption screens (MARGIN=5, ArialBlack 120 value, Arial 64 unit, 40px bar, breakdown at CANVAS_H-MARGIN-110)"
    - "No duplicate percentage calculation in forecast screen — bar label sizing uses fixed representative text"
    - "Debug PNG output for forecast screen renders without errors"
  artifacts:
    - path: "forecast_api.py"
      provides: "Fixed API response parsing"
      contains: "data[\"result\"]"
    - path: "screens/forecast.py"
      provides: "Visually aligned forecast screen renderer"
      contains: "breakdown_y_start = CANVAS_H - MARGIN - 110"
  key_links:
    - from: "forecast_api.py"
      to: "Forecast.Solar API"
      via: "data['result'] direct access (no nested 'watt_hours_day' key)"
      pattern: "watt_hours_day = data\\[.result.\\]"
    - from: "screens/forecast.py"
      to: "rendering/bars.py"
      via: "Manual bar drawing (draw_horizontal_bar auto-appends percentage text, forecast needs custom legend)"
      pattern: "draw\\.rectangle"
---

<objective>
Fix broken Forecast.Solar API parsing and align forecast screen visual style with production/consumption screens.

Purpose: The Forecast.Solar API endpoint `/estimate/watthours/day/` returns a flat `data["result"]` mapping (date -> Wh), not nested under a `watt_hours_day` key. The current code causes a KeyError. Additionally, the forecast screen layout must be verified and tuned to exactly match the unified layout grid used by all other screens.

Output: Working forecast API parsing + visually consistent forecast screen
</objective>

<execution_context>
@/Users/jean-pierrekoenig/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jean-pierrekoenig/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@forecast_api.py
@screens/forecast.py
@screens/production.py
@rendering/bars.py
@models.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix Forecast.Solar API response parsing</name>
  <files>forecast_api.py</files>
  <action>
In `forecast_api.py`, fix the `get_forecast()` method to read the API response correctly.

**Current broken code (line 129):**
```python
watt_hours_day = data["result"]["watt_hours_day"]
```

**Fix — change to:**
```python
watt_hours_day = data["result"]
```

The Forecast.Solar endpoint `/estimate/watthours/day/{lat}/{lon}/{tilt}/{azimuth}/{kwp}` returns JSON where `data["result"]` IS the flat date->Wh mapping (e.g., `{"2026-02-12": 3500, "2026-02-13": 4200}`). There is no nested `watt_hours_day` key.

No other changes needed — the rest of the parsing logic (date lookup, Wh-to-kWh conversion) is correct.
  </action>
  <verify>
Read forecast_api.py and confirm line 129 reads `data["result"]` directly without accessing a nested `watt_hours_day` key. Verify the except clause on line 157 still catches KeyError for safety.
  </verify>
  <done>
The `get_forecast()` method reads `data["result"]` directly as the date->Wh mapping. No `watt_hours_day` nested key access exists in the code.
  </done>
</task>

<task type="auto">
  <name>Task 2: Align forecast screen layout with production/consumption grid</name>
  <files>screens/forecast.py</files>
  <action>
Review and align `screens/forecast.py` with the unified layout grid from `screens/production.py`. The forecast screen already uses most of the correct constants but has one code quality issue to fix:

1. **Remove duplicate percentage calculation** — Lines 57-58 calculate `percentage` for bar label sizing, then line 92 recalculates it. Remove the first calculation (lines 57-58) and use a fixed representative text for sizing (like production.py does with `"Eigenverbrauch 100%"`). Replace the current sizing block:
   ```python
   # Calculate percentage for sizing (will be recalculated for legend)
   percentage = (data.actual_production / data.today_kwh * 100.0) if data.today_kwh > 0 else 0.0

   # Bar label sizing
   if data.today_kwh > 0:
       bar_label_text = f"{int(percentage)}% der Prognose erreicht"
   else:
       bar_label_text = "Keine Prognose verfügbar"
   ```
   with a fixed sizing string:
   ```python
   # Bar label sizing — use fixed representative text for consistent group height
   # (actual legend text computed later, matching how production.py uses "Eigenverbrauch 100%")
   bar_label_text = "100% der Prognose erreicht"
   ```
   This avoids computing percentage twice and makes the group height measurement independent of data values (consistent with production.py's approach).

2. **Verify all layout constants and formulas already match production.py exactly** (no changes needed, just confirm):
   - MARGIN = 5, CANVAS_W/H = 1000/488
   - label_font: Arial 60, value_font: ArialBlack 120, unit_font: Arial 64
   - bar_h = 40, gap_value_bar = 20, gap_bar_label = 5
   - breakdown_y_start = CANVAS_H - MARGIN - 110
   - bar_font: Arial 56, breakdown_value_font: Arial 60
   - `unit_y = value_actual[3] - (unit_actual[3] - unit_actual[1])` — matches production.py line 74
   - `bar_y = value_y + value_h + gap_value_bar` — matches production.py line 77 exactly (do NOT change this)

3. **Generate debug PNG** — After making the change, run a quick test to generate a debug PNG of the forecast screen with sample data to verify it renders correctly:
   ```python
   from models import ForecastData
   from screens.forecast import render_forecast_screen
   from datetime import datetime
   data = ForecastData(today_kwh=8.5, tomorrow_kwh=9.2, actual_production=5.3, fetched_at=datetime.now())
   img = render_forecast_screen(data)
   img.save("debug/forecast_verify.png")
   print("Saved debug/forecast_verify.png")
   ```
   Run it with `python3 -c "..."` from the project root. Verify the output exists.
  </action>
  <verify>
1. Read screens/forecast.py and confirm `bar_y = value_y + value_h + gap_value_bar` (unchanged, matching production.py)
2. Confirm no duplicate percentage calculation before the group height computation — bar_label_text uses fixed sizing string
3. Run: `cd /Users/jean-pierrekoenig/Documents/Projects/solaredge-offgrid-monitor && python3 -c "from models import ForecastData; from screens.forecast import render_forecast_screen; from datetime import datetime; data = ForecastData(today_kwh=8.5, tomorrow_kwh=9.2, actual_production=5.3, fetched_at=datetime.now()); img = render_forecast_screen(data); img.save('debug/forecast_verify.png'); print('OK')"` — should print OK without errors
4. Verify debug/forecast_verify.png exists
  </verify>
  <done>
Forecast screen renders successfully with cleaned-up layout code. Duplicate percentage calculation removed, replaced with fixed sizing string. Bar position formula unchanged (already matches production.py exactly). Debug PNG generated without errors. Layout constants match production/consumption screens exactly.
  </done>
</task>

</tasks>

<verification>
1. `forecast_api.py` reads `data["result"]` directly (no nested `watt_hours_day` key)
2. `screens/forecast.py` uses identical layout constants as `screens/production.py`
3. Forecast screen renders without errors using sample ForecastData
4. Debug PNG output at `debug/forecast_verify.png` shows visually consistent layout
</verification>

<success_criteria>
- Forecast.Solar API response parsing fixed (no KeyError on missing `watt_hours_day` key)
- Forecast screen layout grid matches production/consumption screens (same margins, fonts, spacing, bar positioning)
- Debug PNG generated showing clean, consistent visual output
</success_criteria>

<output>
After completion, create `.planning/phases/10-forecast-fix/10-01-SUMMARY.md`
</output>
