---
phase: 05-operations
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - main.py
autonomous: true

must_haves:
  truths:
    - "Application polls SolarEdge API every 5 minutes (configurable) using monotonic clock deadlines"
    - "Each poll cycle displays 4 screens for 60 seconds each in order: Produktion, Verbrauch, Einspeisung, Bezug"
    - "After cycling all 4 screens, holds on Produktion until next poll"
    - "Application clears display and sleeps between midnight and 6 AM (configurable)"
    - "On wake from sleep, immediately fetches fresh data and starts cycling"
    - "On API failure, keeps showing last successful data"
    - "After 3 consecutive API failures, shows error screen"
    - "On SIGTERM/SIGINT, clears display to white and exits cleanly"
    - "Structured JSON logging used for all operational messages"
  artifacts:
    - path: "main.py"
      provides: "Production-ready polling loop with screen cycling, sleep mode, error handling, graceful shutdown"
      min_lines: 100
  key_links:
    - from: "main.py"
      to: "logging_setup.py"
      via: "setup_logging import and call"
      pattern: "from logging_setup import setup_logging"
    - from: "main.py"
      to: "screens/__init__.py"
      via: "SCREENS import for cycling"
      pattern: "from screens import SCREENS"
    - from: "main.py"
      to: "screens/error.py"
      via: "render_error_screen import"
      pattern: "from screens.error import render_error_screen"
    - from: "main.py"
      to: "solaredge_api.py"
      via: "SolarEdgeAPI for data fetching"
      pattern: "api\\.get_energy_details"
    - from: "main.py"
      to: "display.py"
      via: "Display for rendering and cleanup"
      pattern: "display\\.(render|clear|sleep)"
    - from: "main.py"
      to: "config.py"
      via: "Config for all settings"
      pattern: "config\\.(poll_interval|sleep_start|sleep_end|log_level)"
---

<objective>
Rewrite main.py as a production-ready polling loop that fetches SolarEdge data, cycles through display screens, handles sleep windows, tracks errors, and shuts down gracefully on signals.

Purpose: This is the operational heart of the application -- it replaces the Phase 3 stub with the full production loop that will run 24/7 on the Raspberry Pi.
Output: Complete main.py ready for deployment (Phase 6 wraps it in systemd)
</objective>

<execution_context>
@/Users/jean-pierrekoenig/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jean-pierrekoenig/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-operations/05-CONTEXT.md
@.planning/phases/05-operations/05-RESEARCH.md
@.planning/phases/05-operations/05-01-SUMMARY.md

@main.py
@config.py
@display.py
@solaredge_api.py
@models.py
@screens/__init__.py
@screens/error.py
@logging_setup.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Rewrite main.py with production polling loop</name>
  <files>main.py</files>
  <action>
    Completely rewrite main.py with the following structure. This is the most complex file in the project, so follow the structure carefully:

    **Imports:**
    - `import logging, signal, sys, time` (stdlib)
    - `from datetime import datetime` and `from zoneinfo import ZoneInfo`
    - `from dotenv import load_dotenv` (call `load_dotenv()` immediately after import, BEFORE importing Config)
    - `from config import Config`
    - `from logging_setup import setup_logging`
    - `from solaredge_api import SolarEdgeAPI`
    - `from display import Display`
    - `from screens import SCREENS`
    - `from screens.error import render_error_screen`

    **Module-level:**
    - `shutdown_flag = False` (global, set by signal handler)
    - Screen names list: `SCREEN_NAMES = ["Produktion", "Verbrauch", "Einspeisung", "Bezug"]` (for logging which screen is displayed)

    **signal_handler(signum, frame):**
    - Set `global shutdown_flag = True`
    - Log info with signal name: `signal.Signals(signum).name`
    - Do NOT raise exceptions, do NOT call sys.exit()

    **is_sleep_time(config: Config) -> bool:**
    - Use `ZoneInfo("Europe/Berlin")` for timezone-aware current time
    - Get `now.hour` from `datetime.now(tz)`
    - Handle midnight-crossing: if `sleep_start <= sleep_end`, return `start <= hour < end`; else return `hour >= start or hour < end`
    - Handle edge case: if `sleep_start == sleep_end`, return False (no sleep window)

    **interruptible_sleep(seconds: float) -> bool:**
    - Helper that sleeps in 1-second increments, checking `shutdown_flag` each second
    - Returns True if sleep completed normally, False if interrupted by shutdown
    - This allows responsive shutdown during 60-second screen display waits

    **fetch_data(api: SolarEdgeAPI) -> tuple:**
    - Call `api.get_energy_details()` (screens only need EnergyDetails based on screen signatures)
    - Call `api.get_current_power_flow()` (for logging power data)
    - Return `(energy_details, power_flow)` -- both may be None on failure
    - Log at DEBUG level the raw data received

    **run_screen_cycle(display: Display, data, screen_names: list) -> None:**
    - Iterate through `SCREENS` list (from screens/__init__.py) with `SCREEN_NAMES` for logging
    - For each screen: call `screen_fn(data)` to get PIL Image, then `display.render(image, name)`
    - Log at INFO: which screen is being displayed
    - After rendering each screen, call `interruptible_sleep(60)` -- if it returns False (shutdown), break immediately
    - After cycling all 4 screens, the loop returns (caller holds on Produktion by doing nothing until next poll)

    **main():**
    1. Register signal handlers: `signal.signal(signal.SIGTERM, signal_handler)` and `signal.signal(signal.SIGINT, signal_handler)`
    2. Load config: `config = Config()` (wrapped in try/except ValueError -> log error, sys.exit(1))
    3. Setup logging: `setup_logging(config.log_level)`
    4. Log startup info and call `config.log_startup()`
    5. Create API client: `api = SolarEdgeAPI(config.api_key, config.site_id)`
    6. Create display: `display = Display(debug_mode=config.debug)`
    7. Initialize state:
       - `consecutive_failures = 0`
       - `MAX_FAILURES = 3`
       - `last_successful_data = None` (EnergyDetails or None)
       - `poll_interval_seconds = config.poll_interval * 60`
       - `in_sleep = False`
       - `next_poll = time.monotonic()` (poll immediately on start)
    8. Main loop in `try/finally`:

       **try block -- while not shutdown_flag:**

       a. **Sleep window check:**
          - If `is_sleep_time(config)`:
            - If not `in_sleep`: log "Entering sleep mode", `display.clear()`, set `in_sleep = True`
            - `interruptible_sleep(60)` then `continue`
          - Else if `in_sleep`:
            - Log "Waking from sleep mode"
            - Set `in_sleep = False`
            - Set `next_poll = time.monotonic()` (force immediate poll after wake)

       b. **Poll timing check:**
          - `now = time.monotonic()`
          - If `now < next_poll`: `interruptible_sleep(1)` then `continue` (not time yet)

       c. **Fetch data:**
          - `energy_details, power_flow = fetch_data(api)`
          - If `energy_details is not None`:
            - Reset `consecutive_failures = 0`
            - Store `last_successful_data = energy_details`
            - Log INFO: poll success with summary (e.g., production kWh, consumption kWh from energy_details)
            - Call `run_screen_cycle(display, energy_details, SCREEN_NAMES)`
          - Else (fetch failed):
            - Increment `consecutive_failures`
            - Log WARNING: poll failed with failure count
            - If `consecutive_failures >= MAX_FAILURES`:
              - Log ERROR: "API unreachable after {MAX_FAILURES} consecutive failures"
              - Render error screen: `display.render(render_error_screen(), "error")`
            - Elif `last_successful_data is not None`:
              - Log INFO: "Showing stale data from last successful poll"
              - Render just production screen with stale data: `display.render(SCREENS[0](last_successful_data), "Produktion_stale")`

       d. **Schedule next poll:**
          - `next_poll += poll_interval_seconds`
          - If `next_poll < time.monotonic()`: log warning about long cycle, reset `next_poll = time.monotonic() + poll_interval_seconds`

       **finally block (ALWAYS runs):**
       - Log "Shutting down, clearing display"
       - `display.clear()`
       - `display.sleep()`
       - Log "Shutdown complete"

    **if __name__ == "__main__": main()**

    **IMPORTANT implementation notes:**
    - Use `global shutdown_flag` in signal_handler
    - The interruptible_sleep pattern is critical -- without it, the app would be unresponsive to SIGTERM for up to 60 seconds during screen display
    - Screen renderers only take EnergyDetails (verified from source), NOT PowerFlow -- power_flow is fetched for logging only
    - Do NOT use threading or asyncio -- simple blocking loop per research recommendation
    - Timezone is hardcoded to "Europe/Berlin" per research recommendation
  </action>
  <verify>
    Run syntax check: `cd /Users/jean-pierrekoenig/Documents/Projects/solaredge-offgrid-monitor && python3 -c "import py_compile; py_compile.compile('main.py', doraise=True); print('Syntax OK')"`

    Run import check: `python3 -c "
import os
os.environ['SOLAREDGE_API_KEY'] = 'test'
os.environ['SOLAREDGE_SITE_ID'] = '123'
from main import is_sleep_time, signal_handler, interruptible_sleep, SCREEN_NAMES
from config import Config
c = Config()
print(f'is_sleep_time: {is_sleep_time(c)}')
print(f'SCREEN_NAMES: {SCREEN_NAMES}')
print('All imports OK')
"`

    Verify signal handler sets flag: `python3 -c "
import main
import signal
assert main.shutdown_flag == False
main.signal_handler(signal.SIGTERM, None)
assert main.shutdown_flag == True
print('Signal handler OK')
"`
  </verify>
  <done>
    - main.py is a complete production polling loop with all operational behavior
    - Polls API at configurable interval using monotonic deadlines
    - Cycles 4 screens at 60s each per poll, holds Produktion between polls
    - Enters/exits sleep mode based on configurable time window
    - Tracks consecutive failures, shows error screen after 3
    - Shows stale data on initial failures (before threshold)
    - Clears display on SIGTERM/SIGINT via try/finally
    - Uses structured JSON logging for all operational messages
    - All functions importable and testable individually
  </done>
</task>

<task type="auto">
  <name>Task 2: Install dependencies and verify full system</name>
  <files></files>
  <action>
    1. Install the new dependency: `pip install python-json-logger>=3.0.0`

    2. Run a full import chain verification to ensure all modules wire together:
       ```python
       import os
       os.environ['SOLAREDGE_API_KEY'] = 'test'
       os.environ['SOLAREDGE_SITE_ID'] = '123'
       os.environ['SOLAREDGE_DEBUG'] = 'true'

       from dotenv import load_dotenv
       from config import Config
       from logging_setup import setup_logging
       from solaredge_api import SolarEdgeAPI
       from display import Display
       from screens import SCREENS
       from screens.error import render_error_screen
       from main import is_sleep_time, fetch_data, SCREEN_NAMES

       config = Config()
       setup_logging(config.log_level)
       api = SolarEdgeAPI(config.api_key, config.site_id)
       display = Display(debug_mode=config.debug)

       # Verify screen rendering still works
       from models import EnergyDetails
       test_data = EnergyDetails(production=5.2, self_consumption=3.1, feed_in=1.5, consumption=4.0, purchased=0.9)
       for i, screen_fn in enumerate(SCREENS):
           img = screen_fn(test_data)
           assert img.size == (1000, 488), f"Screen {i} wrong size"
           assert img.mode == '1', f"Screen {i} wrong mode"

       # Verify error screen
       err_img = render_error_screen()
       assert err_img.size == (1000, 488)

       print("Full system verification passed")
       ```

    3. Verify the log file gets created: after running setup_logging, check that `solaredge_monitor.log` exists in the project directory.

    4. Clean up: remove the test log file if created during verification.
  </action>
  <verify>
    The full import chain verification script above runs without errors.
    `pip list | grep python-json-logger` shows the package installed.
  </verify>
  <done>
    - python-json-logger installed and importable
    - All modules import cleanly with no circular dependencies
    - Screen renderers still produce correct 1000x488 mode '1' images
    - Error screen renders correctly
    - Logging creates JSON output to both stdout and file
    - Full system ready for Phase 6 deployment
  </done>
</task>

</tasks>

<verification>
1. `python3 -c "import py_compile; py_compile.compile('main.py', doraise=True)"` -- syntax valid
2. `python3 -c "from main import is_sleep_time, signal_handler, interruptible_sleep, fetch_data, run_screen_cycle, SCREEN_NAMES; print('All exports OK')"` (with env vars set)
3. Signal handler test: set flag, verify it changes
4. is_sleep_time returns bool based on current hour
5. Full import chain runs without circular dependency errors
6. Screen renderers still work with test EnergyDetails data
7. JSON log output visible on stdout when setup_logging called
</verification>

<success_criteria>
- main.py implements complete polling loop matching all Phase 5 requirements
- Application polls at configurable interval, cycles 4 screens at 60s each
- Sleep mode clears display between configurable hours
- 3 consecutive failures trigger error screen
- SIGTERM/SIGINT clears display before exit
- All operational messages use structured JSON logging
- No circular imports, all modules integrate cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/05-operations/05-02-SUMMARY.md`
</output>
