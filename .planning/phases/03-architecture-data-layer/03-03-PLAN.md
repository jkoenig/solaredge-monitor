---
phase: 03-architecture-data-layer
plan: 03
type: execute
wave: 3
depends_on: ["03-01", "03-02"]
files_modified:
  - display.py
  - main.py
autonomous: true

must_haves:
  truths:
    - "Display class auto-detects e-ink or falls back to PNG"
    - "Display class can be instantiated in debug mode (PNG backend)"
    - "main.py imports all modules without circular dependency errors"
    - "main.py can load config and create API client instance"
    - "Running main.py with valid .env shows config and attempts API call"
  artifacts:
    - path: "display.py"
      provides: "Hardware-abstracted display with e-ink/PNG backend"
      contains: "class Display"
      exports: ["Display"]
    - path: "main.py"
      provides: "Application entry point"
      contains: "if __name__"
  key_links:
    - from: "main.py"
      to: "config.py"
      via: "Config import"
      pattern: "from config import Config"
    - from: "main.py"
      to: "solaredge_api.py"
      via: "API client import"
      pattern: "from solaredge_api import SolarEdgeAPI"
    - from: "main.py"
      to: "display.py"
      via: "Display import"
      pattern: "from display import Display"
    - from: "display.py"
      to: "waveshare_epd"
      via: "try-except import fallback"
      pattern: "except ImportError"
---

<objective>
Create the hardware abstraction layer for display and the main entry point that wires all modules together.

Purpose: Complete the modular architecture by adding the display abstraction (for development without hardware) and main.py that proves all modules integrate correctly without circular dependencies.

Output: display.py with Display class (e-ink/PNG auto-detection), main.py as entry point.
</objective>

<execution_context>
@/Users/jean-pierrekoenig/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jean-pierrekoenig/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/03-architecture-data-layer/03-CONTEXT.md
@.planning/phases/03-architecture-data-layer/03-RESEARCH.md
@config.py
@models.py (created in 03-01)
@solaredge_api.py (created in 03-02)
@se-overview.py (reference for display patterns)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create display hardware abstraction</name>
  <files>display.py</files>
  <action>
Create display.py at project root with Display class for hardware abstraction.

**This is a STUB for Phase 4** - implement only the structure, not full rendering logic.

**Pattern from RESEARCH.md:**
```python
import logging
import os
from datetime import datetime

# Try to import e-ink driver
try:
    from waveshare_epd import epd2in13_V3
    EINK_AVAILABLE = True
except ImportError:
    EINK_AVAILABLE = False

class Display:
    """Hardware-abstracted display renderer.

    Auto-detects available backend:
    - E-ink hardware if waveshare_epd available
    - PNG files if not (development mode)
    """

    def __init__(self, debug_mode: bool = False):
        """Initialize display backend.

        Args:
            debug_mode: Force PNG backend even if e-ink available
        """
        self.width = 250
        self.height = 122
        self.scale_factor = 4  # 4x supersampling (render at 1000x488)

        if not debug_mode and EINK_AVAILABLE:
            self.epd = epd2in13_V3.EPD()
            self.epd.init()
            self.epd.Clear(0xFF)
            self.backend = "eink"
            logging.info("Display: E-ink hardware initialized")
        else:
            self.epd = None
            self.backend = "png"
            os.makedirs("debug", exist_ok=True)
            reason = "debug mode" if debug_mode else "driver not found"
            logging.info(f"Display: PNG backend ({reason})")

    def render(self, image, name: str = "screen"):
        """Render image to display or save as PNG.

        STUB: Full rendering logic will be implemented in Phase 4.

        Args:
            image: PIL Image to render (1000x488 high-res)
            name: Base filename for PNG output
        """
        if self.backend == "eink":
            # Scale down and display
            scaled = image.resize((self.width, self.height))
            self.epd.display(self.epd.getbuffer(scaled))
            logging.info(f"Rendered to e-ink display")
        else:
            # Save to debug folder
            filename = f"debug/{name}_{datetime.now():%Y%m%d_%H%M%S}.png"
            image.save(filename)
            logging.info(f"Rendered {self.width}x{self.height} to {filename}")

    def clear(self):
        """Clear the display."""
        if self.backend == "eink" and self.epd:
            self.epd.Clear(0xFF)
            logging.info("Display cleared")

    def sleep(self):
        """Put e-ink display to sleep mode."""
        if self.backend == "eink" and self.epd:
            self.epd.sleep()
            logging.info("Display sleeping")

    def __del__(self):
        """Clean up e-ink driver on shutdown."""
        if hasattr(self, 'backend') and self.backend == "eink" and self.epd:
            try:
                self.epd.sleep()
            except Exception:
                pass
```

**Requirements from CONTEXT.md:**
- Auto-detect display backend (try importing e-ink driver, fall back to PNG)
- Debug PNG files saved to ./debug/ folder
- Verbose logging when rendering to PNG
- No auto-open of PNG files

**DO NOT import from config.py** - receive debug_mode as constructor argument to avoid circular imports.
  </action>
  <verify>
python -c "from display import Display; print('Import OK')"
python -c "from display import Display; d = Display(debug_mode=True); print(f'Backend: {d.backend}')"
python -c "
import logging
logging.basicConfig(level=logging.INFO)
from display import Display
d = Display(debug_mode=True)
print(f'Width: {d.width}, Height: {d.height}, Scale: {d.scale_factor}')
print(f'Backend: {d.backend}')
"
  </verify>
  <done>
Display class exists with auto-detection. In debug mode (or without e-ink driver), backend is "png". Display can be instantiated without errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create main entry point</name>
  <files>main.py</files>
  <action>
Create main.py at project root as application entry point.

**This is a STUB for Phase 5** - implement module wiring and basic verification, not the full polling loop.

```python
#!/usr/bin/env python3
"""
SolarEdge Off-Grid Monitor - Main Entry Point

Run with: python main.py

Requires .env file with:
  SOLAREDGE_API_KEY=your_api_key
  SOLAREDGE_SITE_ID=your_site_id
"""

import logging
import sys

from dotenv import load_dotenv

# Load .env before importing Config (Config reads from environment)
load_dotenv()

from config import Config
from models import PowerFlow, EnergyDetails, SiteOverview
from solaredge_api import SolarEdgeAPI
from display import Display


def main():
    """Main entry point - verify modules work together."""
    # Configure logging
    logging.basicConfig(
        level=logging.DEBUG,
        format='%(asctime)s - %(levelname)s - %(message)s'
    )

    logging.info("SolarEdge Off-Grid Monitor starting...")

    # Load and validate configuration
    try:
        config = Config()
        config.log_startup()
    except ValueError as e:
        logging.error(str(e))
        sys.exit(1)

    # Create API client
    api = SolarEdgeAPI(config.api_key, config.site_id)
    logging.info("API client initialized")

    # Create display (debug mode from config)
    display = Display(debug_mode=config.debug)
    logging.info(f"Display initialized (backend: {display.backend})")

    # Test API call (will fail without valid credentials, but proves wiring works)
    logging.info("Testing API connection...")
    power_flow = api.get_current_power_flow()
    if power_flow:
        logging.info(f"Power flow: {power_flow}")
    else:
        logging.warning("Could not fetch power flow (check API credentials)")

    logging.info("Module integration verified. Full polling loop will be implemented in Phase 5.")


if __name__ == "__main__":
    main()
```

**Key verification points:**
1. All imports succeed without circular dependency errors
2. Config loads from environment (.env)
3. API client can be instantiated
4. Display can be instantiated
5. API call returns data or None (doesn't crash)

**Import order matters:**
1. Load dotenv FIRST (before importing Config)
2. Then import Config (reads from environment)
3. Then import other modules

**DO NOT implement:**
- Polling loop (Phase 5)
- Full display rendering (Phase 4)
- Signal handlers (Phase 5)
  </action>
  <verify>
# Verify imports work
python -c "
from dotenv import load_dotenv
load_dotenv()
from config import Config
from models import PowerFlow, EnergyDetails, SiteOverview
from solaredge_api import SolarEdgeAPI
from display import Display
print('All imports OK - no circular dependencies')
"

# Verify main.py runs (will warn about missing credentials if no .env)
python main.py 2>&1 | head -20
  </verify>
  <done>
main.py exists and runs without import errors. It loads config, creates API client and display, and attempts a test API call. If .env has valid credentials, it fetches data; if not, it logs a warning and exits gracefully.
  </done>
</task>

</tasks>

<verification>
1. display.py exists at project root
2. Display class auto-detects backend (PNG when no e-ink driver)
3. main.py exists at project root
4. `python main.py` runs without import errors
5. All modules can be imported independently:
   - `python -c "from config import Config"`
   - `python -c "from models import PowerFlow"`
   - `python -c "from solaredge_api import SolarEdgeAPI"`
   - `python -c "from display import Display"`
6. No circular import errors
7. Dependency flow: config -> api -> models -> display -> main (left to right)
</verification>

<success_criteria>
- display.py exists with Display class
- Display auto-detects e-ink or PNG backend
- main.py exists as entry point
- main.py successfully imports all modules
- Running `python main.py` with .env shows config and attempts API call
- All modules importable independently (no circular dependencies)
- Architecture requirements ARCH-01, ARCH-02, ARCH-03, ARCH-04 satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/03-architecture-data-layer/03-03-SUMMARY.md`
</output>
