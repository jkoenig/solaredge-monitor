---
phase: 03-architecture-data-layer
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - models.py
  - requirements.txt
autonomous: true

must_haves:
  truths:
    - "PowerFlow dataclass exists with all power flow fields and fetched_at timestamp"
    - "EnergyDetails dataclass exists with all energy meter fields and fetched_at timestamp"
    - "SiteOverview dataclass exists with overview fields and fetched_at timestamp"
    - "requests library is pinned in requirements.txt"
  artifacts:
    - path: "models.py"
      provides: "Data models for API responses"
      contains: "@dataclass(frozen=True)"
      exports: ["PowerFlow", "EnergyDetails", "SiteOverview"]
    - path: "requirements.txt"
      provides: "Python dependencies"
      contains: "requests"
  key_links:
    - from: "models.py"
      to: "stdlib only"
      via: "dataclasses import"
      pattern: "from dataclasses import"
---

<objective>
Create typed data models for SolarEdge API responses and add the requests library dependency.

Purpose: Establish the data layer foundation that API client and display modules will import. Models define the contract between API parsing and display rendering.

Output: models.py with three frozen dataclasses, requirements.txt with requests pinned.
</objective>

<execution_context>
@/Users/jean-pierrekoenig/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jean-pierrekoenig/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-architecture-data-layer/03-CONTEXT.md
@.planning/phases/03-architecture-data-layer/03-RESEARCH.md
@se-overview.py (reference for field names and API response structure)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create data models</name>
  <files>models.py</files>
  <action>
Create models.py at project root with three frozen dataclasses:

1. **PowerFlow** - Current power flow between system elements
   Fields from se-overview.py get_current_power_flow():
   - grid_power: float (kW - negative = purchasing, positive = feeding in)
   - load_power: float (kW - current consumption)
   - pv_power: float (kW - current PV production)
   - storage_power: float (kW - negative = charging, positive = discharging)
   - storage_status: str ("Charge", "Discharge", "Idle")
   - state_of_charge: int (0-100%)
   - off_grid: bool (True if disconnected from grid)
   - fetched_at: datetime (default_factory=datetime.now)

2. **EnergyDetails** - Today's cumulative energy data
   Fields from se-overview.py get_energy_details():
   - production: float (kWh - total PV production today)
   - self_consumption: float (kWh - energy consumed from own production)
   - feed_in: float (kWh - energy exported to grid)
   - consumption: float (kWh - total consumption today)
   - purchased: float (kWh - energy purchased from grid)
   - fetched_at: datetime (default_factory=datetime.now)

3. **SiteOverview** - Site overview with historical data
   Fields from se-overview.py get_site_overview():
   - last_update_time: str (timestamp from API)
   - lifetime_energy: float (MWh - lifetime production)
   - last_year_energy: float (kWh - last 12 months)
   - last_month_energy: float (kWh - last 30 days)
   - last_day_energy: float (kWh - yesterday)
   - fetched_at: datetime (default_factory=datetime.now)

Requirements:
- Use @dataclass(frozen=True) for immutability
- Use field(default_factory=datetime.now) for fetched_at (NEVER use mutable default)
- Add module docstring explaining purpose
- Add docstring to each class documenting units
- Import only from stdlib (dataclasses, datetime)
- NO project imports (models.py is a leaf module)
  </action>
  <verify>
python -c "from models import PowerFlow, EnergyDetails, SiteOverview; print('Imports OK')"
python -c "from models import PowerFlow; p = PowerFlow(0.0, 1.5, 2.0, 0.5, 'Idle', 85, False); print(f'PowerFlow: {p}')"
  </verify>
  <done>
Three frozen dataclasses exist in models.py. Each has fetched_at with default_factory. All can be imported and instantiated without errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update requirements.txt</name>
  <files>requirements.txt</files>
  <action>
Add requests library to requirements.txt:

```
python-dotenv==1.2.1
requests>=2.31.0
```

Note: Use >= for requests (stable API, minor updates are safe). Keep python-dotenv pinned as already established in Phase 2.
  </action>
  <verify>
pip install -r requirements.txt
python -c "import requests; print(f'requests {requests.__version__}')"
  </verify>
  <done>
requirements.txt contains both python-dotenv and requests. pip install succeeds without errors.
  </done>
</task>

</tasks>

<verification>
1. models.py exists at project root
2. All three dataclasses can be imported: `from models import PowerFlow, EnergyDetails, SiteOverview`
3. Dataclasses are frozen (immutable): `PowerFlow(...).grid_power = 5` raises FrozenInstanceError
4. fetched_at defaults to current time when not provided
5. requirements.txt has both dependencies
6. `pip install -r requirements.txt` succeeds
</verification>

<success_criteria>
- models.py exists with PowerFlow, EnergyDetails, SiteOverview dataclasses
- Each dataclass is frozen=True
- Each dataclass has fetched_at: datetime with default_factory
- requirements.txt includes requests>=2.31.0
- All imports work without circular dependency errors
</success_criteria>

<output>
After completion, create `.planning/phases/03-architecture-data-layer/03-01-SUMMARY.md`
</output>
