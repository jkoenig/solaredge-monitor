---
phase: 03-architecture-data-layer
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - solaredge_api.py
autonomous: true

must_haves:
  truths:
    - "SolarEdgeAPI class can be instantiated with api_key and site_id"
    - "API client uses requests.Session with retry logic (3 retries, exponential backoff)"
    - "get_current_power_flow() returns PowerFlow or None"
    - "get_energy_details() returns EnergyDetails or None"
    - "get_site_overview() returns SiteOverview or None"
    - "API errors are logged and return None (never crash)"
  artifacts:
    - path: "solaredge_api.py"
      provides: "SolarEdge API client with retry logic"
      contains: "class SolarEdgeAPI"
      exports: ["SolarEdgeAPI"]
  key_links:
    - from: "solaredge_api.py"
      to: "models.py"
      via: "import dataclasses"
      pattern: "from models import"
    - from: "solaredge_api.py"
      to: "requests.Session"
      via: "HTTP client with retry"
      pattern: "HTTPAdapter.*Retry"
---

<objective>
Create the SolarEdge API client with automatic retry logic and graceful error handling.

Purpose: Encapsulate all SolarEdge API communication in a single class that returns typed data models. Handle network failures gracefully so the display can show stale data instead of crashing.

Output: solaredge_api.py with SolarEdgeAPI class implementing three fetch methods.
</objective>

<execution_context>
@/Users/jean-pierrekoenig/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jean-pierrekoenig/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/03-architecture-data-layer/03-CONTEXT.md
@.planning/phases/03-architecture-data-layer/03-RESEARCH.md
@models.py (created in 03-01)
@se-overview.py (reference for API endpoints and response parsing)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SolarEdge API client</name>
  <files>solaredge_api.py</files>
  <action>
Create solaredge_api.py at project root with SolarEdgeAPI class:

**Class structure:**
```python
class SolarEdgeAPI:
    """Client for SolarEdge Monitoring API with automatic retry."""

    def __init__(self, api_key: str, site_id: str):
        # Store credentials
        # Configure retry: 3 attempts, backoff_factor=2 (delays: 2s, 4s, 8s)
        # status_forcelist=[429, 500, 502, 503, 504]
        # allowed_methods=["GET"]
        # Create requests.Session with HTTPAdapter

    def _request(self, endpoint: str, params: dict = None) -> dict | None:
        # Make request with timeout=10
        # Log errors, return None on failure
        # Return JSON response on success
```

**Implement three methods using patterns from RESEARCH.md:**

1. **get_current_power_flow() -> PowerFlow | None**
   - Endpoint: `/site/{site_id}/currentPowerFlow`
   - Parse response["siteCurrentPowerFlow"]
   - Detect off_grid from connections array (off_grid=True if first connection["from"] != "grid")
   - Return PowerFlow dataclass or None on error

2. **get_energy_details() -> EnergyDetails | None**
   - Endpoint: `/site/{site_id}/energyDetails`
   - Query params: meters=Purchased,FeedIn,Production,SelfConsumption,Consumption
   - Query params: startTime={today} 00:00:00, endTime={today} 23:59:00
   - Parse meters array, extract values by type
   - Convert Wh to kWh (divide by 1000)
   - Return EnergyDetails dataclass or None on error

3. **get_site_overview() -> SiteOverview | None**
   - Endpoint: `/site/{site_id}/overview`
   - Parse response["overview"]
   - Convert energy units (lifetime to MWh, others to kWh)
   - Return SiteOverview dataclass or None on error

**Requirements from CONTEXT.md:**
- HTTP timeout: 10 seconds per request
- Retry 3 times with exponential backoff (2s, 4s, 8s)
- On complete failure: return None (caller handles gracefully)
- API client logs its own errors (logging.error/warning)
- Use defensive parsing with .get() and defaults where possible

**Imports:**
- logging (stdlib)
- requests
- requests.adapters.HTTPAdapter
- urllib3.util.Retry
- datetime (for today's date in energy_details)
- from models import PowerFlow, EnergyDetails, SiteOverview

**Anti-patterns to avoid (from RESEARCH.md):**
- Never create session at module level (encapsulate in class)
- Never retry non-GET methods
- Always include timeout parameter
- Handle KeyError gracefully with try/except
  </action>
  <verify>
python -c "from solaredge_api import SolarEdgeAPI; print('Import OK')"
python -c "from solaredge_api import SolarEdgeAPI; api = SolarEdgeAPI('test_key', 'test_site'); print(f'Session: {api.session}')"
python -c "
from solaredge_api import SolarEdgeAPI
api = SolarEdgeAPI('invalid_key', 'invalid_site')
result = api.get_current_power_flow()
print(f'Result (should be None or error): {result}')
"
  </verify>
  <done>
SolarEdgeAPI class exists with __init__, _request, get_current_power_flow, get_energy_details, get_site_overview methods. Class can be instantiated. Failed API calls return None without crashing.
  </done>
</task>

</tasks>

<verification>
1. solaredge_api.py exists at project root
2. `from solaredge_api import SolarEdgeAPI` succeeds
3. SolarEdgeAPI can be instantiated: `SolarEdgeAPI("key", "site")`
4. Session has retry adapter configured
5. Invalid credentials return None (not crash)
6. No circular imports with models.py
</verification>

<success_criteria>
- solaredge_api.py exists with SolarEdgeAPI class
- Class has __init__ with retry configuration
- Class has _request helper method with timeout=10
- Three public methods: get_current_power_flow, get_energy_details, get_site_overview
- All methods return typed dataclass or None
- Errors are logged, not raised
- No circular dependencies
</success_criteria>

<output>
After completion, create `.planning/phases/03-architecture-data-layer/03-02-SUMMARY.md`
</output>
