---
phase: 08-forecast-screen
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - models.py
  - main.py
  - screens/forecast.py
  - screens/__init__.py
autonomous: true

must_haves:
  truths:
    - "Forecast screen shows 'Prognose, heute' headline in rotation"
    - "Main value displays today's forecast in kWh with 'kWh erwartet' unit label"
    - "Progress bar shows actual production / forecast ratio with German percentage legend"
    - "Bottom area shows tomorrow's forecast with delta vs today"
    - "Screen handles edge states: no data shows error, zero forecast shows 0% bar, >100% shows overflow indicator"
    - "Screen follows unified layout grid (MARGIN=5, headline Arial 60, value ArialBlack 120, bar 40px)"
  artifacts:
    - path: "screens/forecast.py"
      provides: "Forecast screen renderer"
      min_lines: 80
    - path: "models.py"
      provides: "ForecastData with actual_production field"
      contains: "actual_production"
    - path: "screens/__init__.py"
      provides: "Forecast screen imported and registered"
      contains: "render_forecast_screen"
    - path: "main.py"
      provides: "Actual production passed to ForecastData"
      contains: "actual_production"
  key_links:
    - from: "main.py"
      to: "models.ForecastData"
      via: "actual_production field populated from energy_details.production"
      pattern: "actual_production.*energy_details\\.production|energy_details\\.production.*actual_production"
    - from: "screens/__init__.py"
      to: "screens/forecast.py"
      via: "import render_forecast_screen, replaces placeholder"
      pattern: "from screens\\.forecast import render_forecast_screen"
    - from: "screens/forecast.py"
      to: "models.ForecastData"
      via: "render function accepts ForecastData with actual_production"
      pattern: "data\\.actual_production"
---

<objective>
Implement the full "Prognose, heute" forecast screen, replacing the Phase 7 placeholder. The screen shows today's solar production forecast as the main value (ArialBlack 120, "kWh erwartet"), a progress bar comparing actual production vs forecast ("X% der Prognose erreicht"), and tomorrow's forecast with delta in the bottom area ("Morgen: 8.4 kWh (+2.1)").

Purpose: Completes the v1.1 forecast feature by giving homeowners a visual comparison of forecasted vs actual solar production, enabling at-a-glance assessment of how their day is tracking against expectations.
Output: Working forecast screen in rotation, placeholder removed, all edge states handled.
</objective>

<execution_context>
@/Users/jean-pierrekoenig/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jean-pierrekoenig/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@screens/production.py
@screens/battery.py
@screens/__init__.py
@screens/error.py
@models.py
@main.py
@rendering/bars.py
@forecast_api.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add actual_production to ForecastData and wire data routing</name>
  <files>models.py, main.py</files>
  <action>
**models.py** - Add `actual_production` field to ForecastData:

Add a new field `actual_production: float = 0.0` to the ForecastData dataclass. This field carries today's actual PV production from EnergyDetails so the forecast screen can calculate progress percentage without needing a second data argument.

Place it after `tomorrow_kwh` and before `fetched_at`. Add a docstring line: "actual_production: Actual PV production today in kWh (from EnergyDetails, for progress bar)".

**main.py** - Pass actual production through to ForecastData in `fetch_data()`:

In the `fetch_data()` function (around lines 134-139), after getting `forecast_data` from `forecast_api.get_forecast()`, create a new ForecastData that includes the actual production value from energy_details. The logic:

```python
forecast_data = None
if forecast_api:
    raw_forecast = forecast_api.get_forecast()
    if raw_forecast:
        actual_prod = energy_details.production if energy_details else 0.0
        forecast_data = ForecastData(
            today_kwh=raw_forecast.today_kwh,
            tomorrow_kwh=raw_forecast.tomorrow_kwh,
            actual_production=actual_prod,
            fetched_at=raw_forecast.fetched_at,
        )
        logging.debug(f"Fetched forecast: today={forecast_data.today_kwh:.1f} kWh, tomorrow={forecast_data.tomorrow_kwh:.1f} kWh, actual={forecast_data.actual_production:.1f} kWh")
```

This replaces the existing `forecast_data = forecast_api.get_forecast()` + logging block. The key change is wrapping the raw forecast into a new ForecastData that includes `actual_production` from `energy_details.production`.
  </action>
  <verify>
Run `python3 -c "from models import ForecastData; f = ForecastData(today_kwh=5.0, tomorrow_kwh=6.0, actual_production=3.5); print(f'OK: {f.actual_production}')"` and confirm it prints "OK: 3.5".

Run `python3 -c "from models import ForecastData; f = ForecastData(today_kwh=5.0, tomorrow_kwh=6.0); print(f'Default: {f.actual_production}')"` and confirm it prints "Default: 0.0" (default value works).
  </verify>
  <done>ForecastData has actual_production field with default 0.0. main.py populates actual_production from energy_details.production when creating ForecastData for the screen cycle.</done>
</task>

<task type="auto">
  <name>Task 2: Implement forecast screen renderer and register in screen rotation</name>
  <files>screens/forecast.py, screens/__init__.py</files>
  <action>
**screens/forecast.py** - Create the full "Prognose, heute" screen renderer.

Follow the production.py and battery.py patterns exactly. The render function signature is `render_forecast_screen(data: ForecastData) -> Image`.

**Layout (unified grid):**
- MARGIN = 5, CANVAS_W = 1000, CANVAS_H = 488
- Headline: "Prognose, heute" at (MARGIN, MARGIN), Arial 60
- Breakdown area reserved: breakdown_y_start = CANVAS_H - MARGIN - 110 (same as production)
- Value+Bar group vertically centered between headline bottom and breakdown boundary

**Main value (ArialBlack 120):**
- Display `data.today_kwh` formatted as `f"{data.today_kwh:.1f}"`
- Unit label: "kWh erwartet" (Arial 64), baseline-aligned to value (same pattern as production.py lines 72-75)

**Progress bar (manual drawing, like battery.py):**
- Calculate percentage: `(data.actual_production / data.today_kwh * 100.0) if data.today_kwh > 0 else 0.0`
- Bar: 40px tall, full width within margins, 20px below value
- Draw outline: `draw.rectangle((bar_x0, bar_y, bar_x1, bar_y + bar_h), outline=0, width=4)`
- Fill: clamp percentage to 0-100 for fill width calculation: `clamped = min(100.0, percentage)`, then fill_width from clamped
- **Overflow indicator (>100%):** Fill entire bar black, then draw a white rectangle at the right end (last 40px, inset 2px on all sides) to create an inverted "notch" that signals the bar exceeded 100%. This is visible and distinctive on 1-bit display.
- Legend below bar (Arial 56, 5px gap): `f"{int(percentage)}% der Prognose erreicht"` for percentage > 0, or `"0% der Prognose erreicht"` for zero
- If `data.today_kwh <= 0` (no forecast available): legend = "Keine Prognose verfügbar" and bar stays empty

**Bottom breakdown area:**
- Tomorrow's forecast with delta, centered horizontally in the breakdown area
- Use breakdown_value_font (Arial 60) for the text
- Calculate delta: `delta = data.tomorrow_kwh - data.today_kwh`
- Format delta: `f"(+{delta:.1f})"` if delta >= 0, else `f"({delta:.1f})"` (negative sign included automatically)
- Full text: `f"Morgen: {data.tomorrow_kwh:.1f} kWh {delta_text}"`
- If `data.tomorrow_kwh <= 0` and `data.today_kwh > 0`: show `"Morgen: keine Daten"` (tomorrow unavailable)
- If both are 0: show nothing in breakdown area (no forecast data at all)
- Center text horizontally: measure width, calculate x = (CANVAS_W - width) // 2
- Vertically position: `tomorrow_y = breakdown_y_start + (110 - text_h) // 2` to center within breakdown area

**Staleness indicator:**
- Check `data.fetched_at` age: `(datetime.now() - data.fetched_at).total_seconds()`
- If age > 7200 (2 hours): show "Stand: HH:MM" in top-right corner, Arial 36, right-aligned
- This overlaps no other element since headline is left-aligned

**Error state (no data):**
- The forecast screen function will NOT be called with None data (main.py skips it). But if somehow today_kwh is 0 AND tomorrow_kwh is 0, the screen still renders with empty bar and no breakdown text. This is correct for early morning / no forecast available yet.

**screens/__init__.py** - Replace placeholder with real forecast screen:

1. Add import at top: `from screens.forecast import render_forecast_screen`
2. Remove the entire `_placeholder_forecast_screen` function (lines 17-27)
3. In `get_screens()`, change the forecast line from:
   `screens.append((_placeholder_forecast_screen, "forecast", "Prognose"))`
   to:
   `screens.append((render_forecast_screen, "forecast", "Prognose"))`
  </action>
  <verify>
Run `python3 -c "
from models import ForecastData
from screens.forecast import render_forecast_screen

# Test normal case
data = ForecastData(today_kwh=10.0, tomorrow_kwh=12.0, actual_production=6.2)
img = render_forecast_screen(data)
print(f'Normal: {img.size}, mode={img.mode}')

# Test overflow case (>100%)
data2 = ForecastData(today_kwh=8.0, tomorrow_kwh=6.0, actual_production=10.5)
img2 = render_forecast_screen(data2)
print(f'Overflow: {img2.size}, mode={img2.mode}')

# Test zero forecast
data3 = ForecastData(today_kwh=0.0, tomorrow_kwh=5.0, actual_production=0.0)
img3 = render_forecast_screen(data3)
print(f'Zero forecast: {img3.size}, mode={img3.mode}')

# Test both zero
data4 = ForecastData(today_kwh=0.0, tomorrow_kwh=0.0, actual_production=0.0)
img4 = render_forecast_screen(data4)
print(f'No data: {img4.size}, mode={img4.mode}')

print('All render tests passed')
"` — all should print (1000, 488) with mode='1' and no errors.

Run `python3 -c "
from screens import get_screens
screens = get_screens(has_battery=False, has_forecast_config=True)
names = [name for _, _, name in screens]
print(f'Screens: {names}')
assert 'Prognose' in names, 'Forecast screen missing from rotation'
print('Screen registration OK')
"` — should show Prognose in the list.

Verify placeholder is removed: `python3 -c "from screens import _placeholder_forecast_screen"` should raise ImportError.
  </verify>
  <done>
Forecast screen renders correctly for all cases: normal (partial progress), overflow (>100%), zero forecast, and no-data. Screen is registered in rotation replacing the placeholder. "Prognose, heute" headline, "kWh erwartet" unit, "X% der Prognose erreicht" legend, "Morgen: X.X kWh (+X.X)" bottom text, and staleness indicator all render correctly following the unified layout grid.
  </done>
</task>

</tasks>

<verification>
1. Run all render test cases from Task 2 verify section — all produce valid 1000x488 mode '1' images
2. Confirm forecast screen appears in `get_screens()` output when `has_forecast_config=True`
3. Confirm placeholder function is removed from `screens/__init__.py`
4. Confirm `ForecastData` accepts `actual_production` parameter and defaults to 0.0
5. Visual spot-check: save a test image and inspect layout:
   ```python
   from models import ForecastData
   from screens.forecast import render_forecast_screen
   data = ForecastData(today_kwh=10.0, tomorrow_kwh=12.0, actual_production=6.2)
   img = render_forecast_screen(data)
   img.save("/tmp/forecast_test.png")
   ```
</verification>

<success_criteria>
- Forecast screen renders "Prognose, heute" with today's forecast as main value
- Progress bar shows actual/forecast ratio with "X% der Prognose erreicht" legend
- Bottom area shows "Morgen: X.X kWh (+X.X)" with delta
- Overflow indicator visible when actual > forecast (>100%)
- Staleness hint shown when data > 2 hours old
- Zero/no-data edge cases handled gracefully
- Placeholder removed, real screen registered in rotation
- All rendering follows unified layout grid
</success_criteria>

<output>
After completion, create `.planning/phases/08-forecast-screen/08-01-SUMMARY.md`
</output>
